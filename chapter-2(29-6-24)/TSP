#include <stdio.h>
#include <math.h>
#include <limits.h>

// Structure to represent a city with coordinates (x, y)
struct City {
    int x, y;
};

// Function to calculate Euclidean distance between two cities
double distance(struct City city1, struct City city2) {
    return sqrt(pow(city1.x - city2.x, 2) + pow(city1.y - city2.y, 2));
}

// Function to perform Traveling Salesman Problem using brute-force approach
void tsp(struct City cities[], int num_cities) {
    // Initialize variables to store the shortest distance and path
    double min_distance = DBL_MAX;
    int *best_path = NULL;
    
    // Generate all permutations of cities (excluding the starting city itself)
    int perm_count = 1;
    for (int i = 2; i <= num_cities; i++) {
        perm_count *= i;
    }
    
    // Allocate memory for current path
    int *current_path = (int *)malloc(num_cities * sizeof(int));
    
    // Loop through all permutations
    for (int i = 0; i < perm_count; i++) {
        // Create a permutation of cities
        int perm_index = i;
        for (int j = 1; j < num_cities; j++) {
            current_path[j] = j;
        }
        
        // Calculate total distance for the current path
        double current_distance = 0.0;
        for (int j = 1; j < num_cities; j++) {
            current_distance += distance(cities[current_path[j - 1]], cities[current_path[j]]);
        }
        // Add distance from last city back to the starting city
        current_distance += distance(cities[current_path[num_cities - 1]], cities[0]);
        
        // Check if current path gives a shorter distance
        if (current_distance < min_distance) {
            min_distance = current_distance;
            // Update the best path found
            if (best_path == NULL) {
                best_path = (int *)malloc(num_cities * sizeof(int));
            }
            for (int j = 0; j < num_cities; j++) {
                best_path[j] = current_path[j];
            }
        }
        
        // Generate next permutation using std::next_permutation
        if (!next_permutation(current_path + 1, current_path + num_cities)) {
            break;
        }
    }
    
    // Output the shortest distance and the corresponding path
    printf("Shortest Distance: %lf\n", min_distance);
    printf("Shortest Path: ");
    for (int i = 0; i < num_cities; i++) {
        printf("(%d, %d)", cities[best_path[i]].x, cities[best_path[i]].y);
        if (i < num_cities - 1) {
            printf(" -> ");
        }
    }
    printf(" -> (%d, %d)\n", cities[best_path[0]].x, cities[best_path[0]].y); // back to the starting city
    
    // Free dynamically allocated memory
    free(current_path);
    free(best_path);
}

int main() {
    // Test Case 1: Four cities
    struct City cities1[] = {{1, 2}, {4, 5}, {7, 1}, {3, 6}};
    int num_cities1 = sizeof(cities1) / sizeof(cities1[0]);
    tsp(cities1, num_cities1);
    
    // Test Case 2: Five cities
    struct City cities2[] = {{2, 4}, {8, 1}, {1, 7}, {6, 3}, {5, 9}};
    int num_cities2 = sizeof(cities2) / sizeof(cities2[0]);
    tsp(cities2, num_cities2);
    
    return 0;
}
